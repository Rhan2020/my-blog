---
title: "当PM2变成'多胞胎'：一次端口冲突引发的CI/CD惊魂记"
date: "2024-12-19"
description: "一个端口冲突如何让我彻夜难眠，以及如何从这场'3000端口保卫战'中学到的关键部署经验"
tags: ["技术开发", "部署"]
---

# 当PM2变成"多胞胎"：一次端口冲突引发的CI/CD惊魂记

想象一下，你刚刚推送了一个完美的代码更新，GitHub Actions显示一切绿灯🟢，但打开网站后...一片空白！😱 这就是我最近遇到的情况，而罪魁祸首竟是一个看似无辜的端口冲突问题。

## 🔍 当3000端口被围攻

那是一个平静的周四晚上，我像往常一样推送了代码更新。CI/CD流程顺利完成，但当我兴高采烈地打开网站准备欣赏新功能时，却看到了这个让人心碎的错误：

```
Error: listen EADDRINUSE: address already in use :::3000
```

这就像你精心准备了一场派对，却发现家门口已经挤满了不速之客！🚪👥

## 🕵️‍♂️ 侦探模式：开启

连接到服务器后，我使用了`pm2 list`命令，眼前的景象让我大吃一惊：

```bash
pm2 list
```

结果显示有**14个**同名的`my-blog`进程在运行！这就像你发现自己养的一只猫🐱神秘地变成了十四只，全都挤在同一个猫窝里争抢食物。

## 🔎 揭开谜底

经过一番"犯罪现场"调查，我发现问题出在CI/CD配置中的PM2管理逻辑：

```yaml
- name: Smart PM2 Service Management
  script: |
    if pm2 show my-blog > /dev/null 2>&1; then
      echo "应用已存在，执行重载"
      if pm2 reload my-blog; then
        echo "应用重载成功"
      else
        echo "重载失败，尝试重启"
        pm2 restart my-blog
      fi
    else
      echo "应用不存在，启动新应用"
      pm2 start npm --name "my-blog" -- start
    fi
```

这段代码的问题就像是一个没有"else"的"if-then-else"语句 — 如果重载失败，它会尝试重启，但如果重启也失败呢？没有处理！就像是消防演习中只计划了一条逃生路线，却没有考虑这条路线被阻断的情况。🚒

每次部署失败，它都会创建一个新进程，却不会清理旧进程。随着时间推移，这些"幽灵进程"越来越多，全都试图占用同一个端口，最终导致了这场"3000端口保卫战"。

## 💡 拯救行动

### 1. 紧急止血

首先，我需要清理这些失控的进程，就像是给电脑做一次彻底的"数字排毒"：

```bash
# 删除所有PM2进程（就像重启一台卡住的电脑）
pm2 delete all

# 确认端口释放（检查房子是否真的空了）
lsof -i:3000 || echo '端口3000已释放'

# 重新启动单个应用（重新开始，保持整洁）
pm2 start npm --name 'my-blog' -- start
```

### 2. 重建防线

为了防止历史重演，我重新设计了PM2管理逻辑，就像是升级家里的安全系统：

```yaml
- name: Robust PM2 Service Management
  script: |
    # 强制清理可能存在的重复进程（先清空房间）
    pm2 delete my-blog 2>/dev/null || true
    
    # 等待端口释放（给系统一点喘息的时间）
    sleep 2
    
    # 启动新应用（重新开始，一切整洁有序）
    pm2 start npm --name "my-blog" -- start
    
    # 验证启动状态（检查一切是否正常）
    sleep 5
    if ! pm2 show my-blog > /dev/null 2>&1; then
      echo "应用启动失败"
      exit 1
    fi
```

这就像是从"希望它能工作"升级到"确保它能工作"的思维转变。

### 3. 建立预警系统

在CI/CD流程中增加了健康检查，就像是给应用装上了心电监测仪：

```yaml
- name: 应用健康检查
  script: |
    # 检查PM2状态（应用是否活着）
    if ! pm2 show my-blog | grep -q "online"; then
      echo "应用未正常运行"
      pm2 logs my-blog --lines 20
      exit 1
    fi
    
    # 检查端口监听（应用是否在工作岗位上）
    if ! lsof -i:3000 > /dev/null 2>&1; then
      echo "端口3000未被监听"
      exit 1
    fi
    
    # HTTP健康检查（应用是否能正常交流）
    for i in {1..5}; do
      if curl -f -s http://localhost:3000 > /dev/null; then
        echo "应用健康检查通过"
        break
      else
        if [ $i -eq 5 ]; then
          echo "应用健康检查失败"
          exit 1
        fi
        sleep 3
      fi
    done
```

## 🧠 经验与教训

这次事件教会了我一些宝贵的部署经验：

1. **不要相信"看起来成功"的部署** — 就像不要只看蛋糕的外表，内部可能还是生的
2. **总是验证实际结果** — 部署后亲自检查功能，就像买了新车一定要试驾
3. **失败处理比成功处理更重要** — 规划最坏情况的应对，就像随身携带雨伞
4. **定期清理比事后修复容易** — 预防胜于治疗，这在软件和健康方面都适用

## 🤔 你的CI/CD健康吗？

看完我的故事，不妨检查一下你自己的部署流程：

- 你的CI/CD是否有完善的失败处理机制？
- 部署后是否有自动化的健康检查？
- 是否定期清理旧的构建和进程？

如果你也有类似的"部署惊魂"故事，欢迎在评论区分享！我很想知道你是如何解决这些棘手问题的。🙌

---

记住，一个健壮的CI/CD流程就像一个可靠的朋友 — 不仅在一切顺利时陪伴你，更重要的是在困难时刻帮助你渡过难关。 